<?php

declare(strict_types=1);

namespace snuze\Reddit\Listing;

use snuze\{
    Reddit\Thing\Account\UserAccount,
    Reddit\Thing\Link,
    Reddit\Thing\Subreddit,
    Reddit\Thing\Thing
};

/**
 * A Listing represents a collection of Thing objects returned from the Reddit
 * API in response to some request. It implements \IteratorAggregate and
 * \Countable, so foreach() and count() can both be used directly on a Listing
 * object.
 *
 * A generic Listing can hold a heterogeneous mixture of all kinds of Things:
 * Subreddits, Accounts, Comments, Messages, etc. For more strict collections,
 * use a subtype: SubredditListing, LinkListing, CommentListing, etc.
 *
 * *****************************************************************************
 * This file is part of Snuze, a PHP client for the Reddit API.
 * Copyright 2019 Shaun Cummiskey <shaun@shaunc.com> <https://shaunc.com/>
 * Repository: <https://github.com/snuze/snuze/>
 * Documentation: <https://snuze.shaunc.com/>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Listing extends \snuze\SnuzeObject implements \Countable, \IteratorAggregate, \snuze\Interfaces\Jsonable
{

    /**
     * An "after" (next page begins after) specifier, as a thing fullname
     *
     * @var string|null
     */
    private $after = null;

    /**
     * A "before" (previous page ends before) specifier, as a thing fullname
     *
     * @var string|null
     */
    private $before = null;

    /**
     * A modification hash to mitigate CSRF. This is only used in toJson().
     *
     * @var string|null
     */
    private $modhash = null;

    /**
     * An array holding the collection of Thing objects in this Listing. There
     * is no getter for this property: to iterate over the collection, use
     * foreach() on the Listing object itself.
     *
     * @var Thing[]
     */
    protected $children = [];

    /**
     * The original JSON used to create this Listing object via its fromJson()
     * method, if applicable. Typically, this will be the JSON response from
     * the Reddit API server. Used by the test suite to ensure that the JSON
     * generated by toJson() is functionally equivalent to what Reddit sent us.
     *
     * @var string
     */
    protected $_sourceJson = '';

    /**
     * Constructor.
     */
    public function __construct() {

        /* All SnuzeObject subtypes must call parent ctor */
        parent::__construct();
        $this->debug('ctor args: ' . var_export(func_get_args(), true));
    }

    /**
     * Get this listing's "after" specifier, if any. If a value is returned, it
     * corresponds to the fullname of the last entity in the collection, and can
     * be used for forward pagination.
     *
     * @return string|null
     */
    public function getAfter(): ?string {
        return $this->after;
    }

    /**
     * Get this listing's "before" specifier, if any. If a value is returned, it
     * corresponds to the fullname of the first entity in the collection, and can
     * be used for reverse pagination.
     *
     * @return string|null
     */
    public function getBefore(): ?string {
        return $this->before;
    }

    /**
     * Get the original JSON used to create this object via fromJson(), if
     * applicable. This is intended for use by the test suite. You probably
     * want toJson() instead!
     *
     * @return string If this object was created using fromJson(), the original
     *      JSON provided; otherwise, an empty string
     */
    public function _getSourceJson(): string {
        return $this->_sourceJson;
    }

    /**
     * Add a Thing to the collection. Accurate type hinting of the argument
     * isn't possible yet, so it must be tested manually.
     *
     * @param \snuze\Reddit\Thing\Thing $thing A Thing object to add
     *      to the collection
     * @return void
     * @throws \snuze\Exception\ArgumentException
     * @todo Revisit this (&& overrides) once PHP 7.4 covariance is mainstream
     */
    public function add($thing): void {

        if (!$thing instanceof \snuze\Reddit\Thing\Thing) {
            throw new \snuze\Exception\ArgumentException($this,
                    'Argument to add() must be a Thing object');
        }

        $this->children[] = $thing;
    }

    /**
     * Implement the \Countable interface. This allows count() to be called on
     * Listing objects
     *
     * @return int
     */
    public function count(): int {
        return count($this->children);
    }

    /**
     * Implement the \IteratorAggregate interface. This allows foreach() to be
     * used productively on Listing objects
     *
     * @return \Traversable
     */
    public function getIterator(): \Traversable {
        foreach ($this->children as $child) {
            yield $child;
        }
    }

    public function toJson(): string {

        /*
         * First, each child needs to be converted into an array suitable for
         * passing into json_encode() later
         */
        $children = [];
        foreach ($this->children as $child) {
            $children[] = json_decode($child->toJson(), true);
        }

        /* Build an array representing this Listing object */
        $arr = [
            'kind' => 'Listing',
            'data' => [
                'modhash'  => $this->modhash,
                'dist'     => count($children),
                'children' => $children,
                'after'    => $this->after,
                'before'   => $this->before,
            ]
        ];

        /* Return the JSON string */
        return json_encode($arr,
                JSON_UNESCAPED_SLASHES | JSON_PRESERVE_ZERO_FRACTION);
    }

    /**
     * Given the raw JSON response to any API request that returns a listing,
     * attempt to create a Listing object whose $children array is full of Thing
     * descendants.
     *
     * @param string $json The raw JSON response from Reddit's API server
     * @return \snuze\Reddit\Listing
     * @throws \snuze\Exception\RuntimeException
     */
    public function fromJson(string $json): Listing {

        /* Cache the incoming JSON; this may be used by the test suite */
        $this->_sourceJson = $json;

        /* Turn the incoming JSON into an array for easier manipulation */
        if (empty($j = json_decode($json, true))) {
            throw new \snuze\Exception\RuntimeException($this,
                    'Incoming $json was empty or ' . "couldn't be decoded.");
        }

        /* First, set outermost properties if they exist in the JSON */
        if (!empty($j['data']['after'])) {
            $this->after = $j['data']['after'];
        }
        if (!empty($j['data']['before'])) {
            $this->before = $j['data']['before'];
        }

        /* Next, ensure the 'children' element is present in the JSON */
        if (!isset($j['data']['children'])) {
            throw new \snuze\Exception\RuntimeException($this,
                    "Expected ['data']['children'] element missing from JSON");
        }
        if (empty($j['data']['children'])) {
            $this->info("JSON ['data']['children'] element was empty, no results?");
        }

        /* Attempt to turn all the Things into objects */
        foreach ($j['data']['children'] as $thing) {

            /* Convert this individual Thing back to JSON */
            $thingJson = json_encode($thing,
                    JSON_UNESCAPED_SLASHES | JSON_PRESERVE_ZERO_FRACTION);

            /* What kind of Thing is this? */
            switch ($thing['kind']) {

                case Thing::KIND_COMMENT:
                    //@todo not yet implemented
                    throw new \snuze\Exception\RuntimeException($this,
                            'Not yet implemented: ' . var_export($thing, true));
                    break;

                case Thing::KIND_ACCOUNT:
                    $this->add((new UserAccount())->fromJson($thingJson));
                    break;

                case Thing::KIND_LINK:
                    $this->add((new Link())->fromJson($thingJson));
                    break;

                case Thing::KIND_MESSAGE:
                    //@todo not yet implemented
                    throw new \snuze\Exception\RuntimeException($this,
                            'Not yet implemented: ' . var_export($thing, true));
                    break;

                case Thing::KIND_SUBREDDIT:
                    $this->add((new Subreddit())->fromJson($thingJson));
                    break;

                case Thing::KIND_AWARD:
                    //@todo not yet implemented
                    throw new \snuze\Exception\RuntimeException($this,
                            'Not yet implemented: ' . var_export($thing, true));
                    break;

                default:
                    throw new \snuze\Exception\RuntimeException($this,
                            'Unrecognized Thing: ' . var_export($thing, true));
            }
        }

        return $this;
    }

}
